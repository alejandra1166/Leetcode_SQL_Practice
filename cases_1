
--Day 3-4

SELECT s.user_id, COUNT(IIF(c.action = 'confirmed', c.user_id, null))/CAST(COUNT(*) as decimal(3,2)) AS confirmation_rate			
FROM confirmations as c
FULL JOIN signups as s
ON c.user_id = s.user_id
group by  s.user_id


--Day 3-5

SELECT * 
FROM CINEMA
WHERE description <> 'boring' AND id % 2 <> 0
order by rating DESC


--Day 4-1


SELECT p.product_id, CAST((SUM(units * price))as float)/SUM(units)
FROM prices AS p
inner JOIN unitssold as u
ON p.product_id = u.product_id
where purchase_date between start_date and end_date
group by p.product_id


--Day 4-2

SELECT project_id, CAST(SUM(experience_years)AS decimal(3,2))/COUNT(*)as avg_years
FROM employee_3 as e
JOIN project as p
on e.employee_id = p.employee_id
group by project_id



	SELECT project_id, CAST(AVG(experience_years +.0) AS DECIMAL(4,2))
    FROM  employee_3 AS e
    INNER JOIN project AS p
      ON e.employee_id = p.employee_id
 GROUP BY project_id

 --Day 4-3

SELECT contest_id, ((COUNT(DISTINCT user_id)/ (select count(user_id)+.0 from users)) * 100) as percentage
from register
group by contest_id
ORDER BY percentage DESC
 
 --Day 4-4

	--quality

SELECT query_name, CAST(AVG(rating/position+.0) AS DECIMAL(4,2)) as queries_quality
FROM queries
group by query_name

--did it by myself

--poor_ query_percentage


SELECT query_name, (COUNT(rating)/((select count(rating)+.0  from queries)))*100
FROM queries
WHERE rating < 3
GROUP BY query_name

select count(rating)
FROM queries
WHERE rating < 3
GROUP BY query_name

---needed a way to add the where into the select...people helped me so


--Final result : 

select query_name, 
		CAST(AVG(rating/position+.0) AS DECIMAL(4,2)) as quality, 
		COUNT(CASE WHEN rating < 3 THEN 1 END) / (COUNT(*) * 1.0) as  poor_query_percentage
from queries
GROUP BY query_name
order by query_name DESC


--Day 4-5

--first, group by

select sum(amount)
from transactions_bank
group by DATEPART(month, trans_date), country

--the number of transactions and their total amount,


select COUNT(id) as trans_count, sum(amount) as trans_total_amount, 
from transactions_bank
group by DATEPART(month, trans_date), country


--Count of approved transactions 
select  country, COUNT(id) as trans_count, sum(amount) as trans_total_amount, COUNT(case when state = 'approved' THEN 1 END) as approved_count
from transactions_bank
group by DATEPART(month, trans_date), country


--total SUM of approved transactions

select  country
		,COUNT(id) as trans_count
		,SUM(amount) as trans_total_amount
		,COUNT(case when state = 'approved' THEN 1 END) as approved_count
		,SUM(case when state = 'approved' THEN amount ELSE 0 END) as approved_total_amount

from transactions_bank
group by DATEPART(month, trans_date), country

--Final result 

select  FORMAT(trans_date, 'MM-yyyy') as months
		,country
		,COUNT(id) as trans_count
		,SUM(amount) as trans_total_amount
		,COUNT(case when state = 'approved' THEN 1 END) as approved_count
		,SUM(case when state = 'approved' THEN amount ELSE 0 END) as approved_total_amount

from transactions_bank
group by FORMAT(trans_date, 'MM-yyyy'), country

--using only format, because it wil give u month 12 abd year 2019 and thats all u need to group by too


--DAY 5-1

--immediate = If the customer's preferred delivery date is the same as the order date  otherwise
--scheduled = otherwise
--The first order of a customer is the order with the earliest order date that the customer made

-- find the percentage of IMMEDIATE orders in the FIRST  orders of all customers, rounded to 2 decimal places.

--+----------------------+
--| immediate_percentage |
--+----------------------+
--| 50.00                |
--+----------------------+



--SELECT * FROM delivery

SELECT customer_id, order_date 
FROM delivery

--getting only te 1st orders


SELECT *
FROM (SELECT customer_id, order_date, customer_pref_delivery_date,RANK() OVER   
    (PARTITION BY customer_id ORDER BY order_date) as ranks
		from delivery) as delivery_rank
where ranks = 1

--doing the math and finding the percentage

SELECT (SUM(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END)  * 100)/COUNT(customer_pref_delivery_date ) as immediate_percentage

FROM (SELECT customer_id, order_date, customer_pref_delivery_date,RANK() OVER   
    (PARTITION BY customer_id ORDER BY order_date) as ranks
		from delivery) as delivery_rank
where ranks = 1


--Day 5-2
--report the fraction of players that logged in again on the day after the day they first logged in, on other words:
--count the number of players that logged in for at least two consecutive days starting from their first login date, 
--then divide that number by the total number of players.

--+-----------+
--| fraction  |
--+-----------+
--| 0.33      |
--+-----------+


--counting repetitive days

WITH cte1 AS (
SELECT  event_date, DATEADD(d, - ROW_NUMBER() OVER  (ORDER BY event_date), event_date) as prev_date, player_id
FROM activity_players
)

SELECT COUNT(prev_date)
FROM cte1
group by  prev_date

--FINDING THE RESULT

WITH cte1 AS (
SELECT  event_date, DATEADD(d, - ROW_NUMBER() OVER  (ORDER BY event_date), event_date) as prev_date, player_id
FROM activity_players
)

SELECT CAST((CASE WHEN COUNT(prev_date) = 2.0 THEN 1 ELSE 0 END ) AS DECIMAL(4,2))/ (SELECT COUNT(DISTINCT player_id) FROM activity_players)+.0
FROM cte1
group by  prev_date


--Day 5-3

--calculate the number of unique subjects each teacher teaches in the university.

--+------------+-----+
--| teacher_id | cnt |
--+------------+-----+
--| 1          | 2   |
--| 2          | 4   |
--+------------+-----+

-- SELECT * FROM teacher


SELECT teacher_id, COUNT(DISTINCT subject_id) as cnt
FROM teacher
group by teacher_id


--Day 5-4
-- find the daily active user count for a period of 30 days ending 2019-07-27 inclusively.
--A user was active on someday if they made at least one activity on that day.
--+------------+--------------+ 
--| day        | active_users |
--+------------+--------------+ 
--| 2019-07-20 | 2            |
--| 2019-07-21 | 2            |
--+------------+--------------+ 

SELECT activity_date, COUNT(DISTINCT user_id) as active_users
FROM activity_sm
where activity_date BETWEEN Dateadd(day,-30,'2019-07-27') AND  '2019-07-27'
group by activity_date


--Day 5-5

--Write a solution to select the product id, year, quantity, and price for the first year of every product sold.

--+------------+------------+----------+-------+
--| product_id | first_year | quantity | price |
--+------------+------------+----------+-------+ 
--| 100        | 2008       | 10       | 5000  |
--| 200        | 2011       | 15       | 9000  |
--+------------+------------+----------+-------+

--joining 

SELECT sales.product_id,  year, quantity, price
FROM phone_sales as sales
JOIN phone_product as product
ON sales.product_id=product.product_id

--raking products by year

SELECT sale_id, product_id,  year, quantity, price, RANK() OVER (PARTITION BY product_id order by year) ranks
FROM phone_sales

--solving it

SELECT sales.product_id,  year, quantity, price
FROM (
	SELECT sale_id
				, product_id
				,  year
				, quantity
				, price
				, RANK() OVER (PARTITION BY product_id order by year) ranks
	FROM phone_sales
	) as sales
JOIN phone_product as product
ON sales.product_id=product.product_id
where ranks = 1



--Day 6-1

--find all the classes that have at least five students.
--+---------+
--| class   |
--+---------+
--| Math    |
--+---------+

--SELECT * FROM courses

SELECT class
FROM 
	(SELECT COUNT(student) over (partition by class) as counted, class
	FROM courses) as courses_counted
where counted >= 5
group by class

--Day 6-2

--Write a solution that will, for each user, return the number of followers.
--      Return the result table ordered by user_id in ascending order.

--+---------+----------------+
--| user_id | followers_count|
--+---------+----------------+
--| 0       | 1              |
--| 1       | 1              |
--| 2       | 2              |
--+---------+----------------+

--SELECT * FROM followers

SELECT user_id, count(follower_id)
FROM followers
group by user_id
order by user_id


--Day 6-3

----A single number is a number that appeared only once in the MyNumbers table.
--      Find the largest single number. 
--	  If there is no single number, report null.

--+-----+
--| num |
--+-----+
--| 6   |
--+-----+

SELECT MAX(num) as num
FROM (
	select count(*) as counted, num
	from mynumbers
	group by num ) as grouped_num
where counted = 1

--Day 6-4

--Write a solution to report the customer ids from the Customer table that bought all the products in the Product table.
+-------------+
| customer_id |
+-------------+
| 1           |
| 3           |
+-------------+

SELECT * FROM customer_two 
SELECT * FROM product_two

SELECT customer_id
FROM (
		SELECT product_key
				,customer_id
				,rank() over (partition by customer_Id order by product_key) as ranks
		FROM customer_two 
		) as table_ranked
where ranks = 2

--Day 6-5

--we will consider a manager an employee who has at least 1 other employee reporting to them.
--report the ids and the names of all managers,
--the number of employees who report directly to them,
--and the average age of the reports rounded to the nearest integer.
-- Return the result table ordered by employee_id.

+-------------+-------+---------------+-------------+
| employee_id | name  | reports_count | average_age |
+-------------+-------+---------------+-------------+
| 9           | Hercy | 2             | 39          |
+-------------+-------+---------------+-------------+

--select * from employees_4

select one.employee_id, one.name, COUNT(two.employee_id) as reports_to_manager, AVG(two.age) as av_age
from employees_4 as one
JOIN employees_4 as two
ON one.employee_id = two.reports_to
group by one.employee_id, one.name


--Day 7-1

--primary_flag is an ENUM (category) of type ('Y', 'N'). If the flag is 'Y', the department is the primary department for the employee. If the flag is 'N', the department is not the primary.
--Note that when an employee belongs to only one department, their primary column is 'N'

--Report all the employees with their primary department. 
--For employees who belong to one department, report their only department.

--+-------------+---------------+
--| employee_id | department_id |
--+-------------+---------------+
--| 1           | 1             |
--| 2           | 1             |
--| 3           | 3             |
--| 4           | 3             |
--+-------------+---------------+

--SELECT * FROM employees_5

SELECT employee_id, department_id
FROM (
	SELECT employee_id
		, COUNT(primary_flag) over (partition by employee_id) as numb_departments
		, department_id
		, primary_flag
	FROM employees_5
	) AS employees 
WHERE numb_departments = 1 OR primary_flag = 'Y'


--Day 7-2

--Report for every three line segments whether they can form a triangle.
--the sum of the lengths of any two sides of a triangle is always greater than the length of the third side

--+----+----+----+----------+
--| x  | y  | z  | triangle |
--+----+----+----+----------+
--| 13 | 15 | 30 | No       |
--| 10 | 20 | 15 | Yes      |
--+----+----+----+----------+

SELECT x, y, z, CASE
				WHEN X + Y >= z
				THEN 'Yes'
				ELSE 'No'
				END as triangle
FROM triangle


--Day 7-3

--Find all numbers that appear at least three times consecutively.

--+-----------------+
--| ConsecutiveNums |
--+-----------------+
--| 1               |
--+-----------------+

WITH cte1 as (
SELECT id
	, num
	, LAG(num) over (order by id)as lag_num
	, LEAD(num) over (order by id) as lead_num
FROM logs
)

SELECT num as ConsecutiveNums
from cte1
where num = lag_num 
		AND
		num = lead_num




